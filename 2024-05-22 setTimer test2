
 1  //

setTimeout(function(){
  console.log("1.너구리가 공중부양");
},500)

 결과 -> 1000(1초)의 반이니까 0.5 초 걸린다.





 2  //

setTimeout(function(){
  console.log("1. 너구리가 공중부양");

setTimeout(function(){
  console.log("2. 방방구가 보고싶다");
}, 1000)

},1000)

결과 :
1. 너구리가 공중부양
2. 방방구가 보고싶다

비동기 함수를 동기화 시킨 것이다. 
순서를 어기는 놈을 순서를 지키게 만드는 유일한 방법 -> "callback"

callback : 문법이자, 패턴이다. "함수가 함수를 부르는 것" 자체를 "callback"이라고 부른다. 
addEventListener도 함수가 함수를 불러 일을 시키는 것이기 때문에 callback이다.
헷갈리는 부분 : 전에 callback 이라고 작성 했던 것은 "직접 작성"법.
지금 쓰는 것은 패턴(개념 론)이다.

너구리 함수가 실행이 되면, 그 후에 방방구 함수가 실행이 되는 구조이다. 
(너구리 = 부모, 방방구 = 자식)이라서 1초후 실행되게 설정된 것은 동일하지만, 부모 먼저 그 후에 자식 순서대로 실행 된 것이다.
방방구가 0.5초, 너구리가 3초여도 무조건 너구리 함수부터 실행된다.
사람은 총 실행 시간이 2초라고 생각하지만, 컴퓨터는 절차적으로 너구리 1초 -> 방방구1초 순으로 각 1초로 실행한 것이다.





 3  //

setTimeout(function() {
  console.log("1. 기타는 일렉이지");

  a();

}, 1000)

function a() {
  setTimeout(function() {
    console.log("2. 일렉은 메탈이지");
  }, 1000)

}

결과 :
1. 기타는 일렉이지
2. 일렉은 메탈이지

위의 2번 예시를 살짝 변형한 상태이다.
2번 예시가 함수 안에 함수를 직접적으로 작성했다면, 
3번 예시는 a라는 함수를 만든 후 , 1번 함수 안에 간접적으로 넣은 것이다.

또 다른 예시 : 
(지원, 가흥 둘다 물을 너무 먹고 싶다) 지원아 너 물 먼저 마시고 그다음에 가흥이 불러서 마시라 해.





 4  //

setTimeout(function() {
  console.log("1.김윤아");
}, 3000);

setTimeout(function() {
  console.log("2.이선균");
}, 2000);

setTimeout(function() {
  console.log("3.김진만");
}, 1000);

결과 :
3.김진만
2.이선균
1.김윤아

3-2-1 순으로 나온다.
쓰여진 순서가 아닌, 가장 짧은 시간 순대로 정렬 된 것이다.

과제 : 1-2-3 순으로 나오게 만들기
내가 생각 한 것 -> 김윤아 함수 안에, 이선균 함수 안에, 김진만 함수 넣기. (부모-자식 관계 사용)

정답 :
setTimeout(function() {
  console.log("1.김윤아");

  setTimeout(function() {
    console.log("2.이선균");

    setTimeout(function() {
      console.log("3.김진만");
    }, 1000);

  }, 2000);

}, 3000);

결과 :
1.김윤아
2.이선균
3.김진만

1.김윤아(3초) - 2.이선균(2초) - 3.김진만(1초) 순으로 실행된다.
김윤아(3초)함수 안에 있다고 해서, 나머지 함수들도 모두 3초가 걸리는 것이 아니다. 각각의 설정된 시간대로 실행 된다.
1번 김윤아 함수가 실행되는 시점에서 실행되는 함수(2.이선균)속의 함수(3.김진만).

